<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Low-Poly Procedural World (A-Frame)</title>
  <!-- Tailwind CSS CDN for quick utility styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Simplex Noise for terrain generation -->
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.min.js" type="module"></script>
  <style>
    .hud-shadow { text-shadow: 0 1px 2px rgba(0,0,0,0.6); }
  </style>
</head>
<body class="bg-black">
  <!-- Loading Screen -->
  <div id="loading" class="fixed inset-0 flex items-center justify-center bg-black/90 z-50">
    <div class="text-center text-white">
      <div class="text-2xl font-semibold">Generating worldâ€¦</div>
      <div class="mt-2 text-sm opacity-80">Chunked terrain, trees, rocks, background</div>
    </div>
  </div>

  <!-- Debug HUD removed -->

  <!-- A-Frame Scene -->
  <a-scene renderer="colorManagement: true; antialias: true;" background="color: #88a9c3">
    <!-- Ambient + Directional Light -->
    <a-entity light="type: ambient; intensity: 0.6"></a-entity>
    <a-entity light="type: directional; intensity: 0.9" position="1 1 0"></a-entity>

    <!-- Player rig; camera grounding handled via system below -->
    <a-entity id="rig" position="0 2 0" auto-walk>
      <a-entity id="camera" camera look-controls position="0 0 0" camera="near: 0.2"></a-entity>
    </a-entity>

    <!-- Terrain/World Root -->
    <a-entity id="world" chunked-terrain></a-entity>

    <!-- Birds -->
    <a-entity id="birds" bird-flock></a-entity>

    <!-- Rabbits -->
    <a-entity id="rabbits" rabbit-pack></a-entity>

    <!-- Simple Sky -->
    <a-sky color="#9db3c6"></a-sky>
  </a-scene>

  <script type="module">
    // Import simplex-noise from module script tag
    import { createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.min.js';

    // Utility: clamp
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // World Config
    const CONFIG = {
      chunkSize: 20,            // meters per chunk
      vertsPerSide: 21,         // grid resolution (must be >= 2)
      drawDistance: 4,          // chunks radius to keep loaded
      terrainScale: 0.06,       // base frequency for terrain
      terrainAmplitude: 8.0,    // base height scale
      octaves: 4,               // fractal noise octaves
      lacunarity: 2.0,          // frequency multiplier per octave
      gain: 0.5,                // amplitude multiplier per octave
      macroScale: 0.012,        // very low-frequency macro hills
      macroAmplitude: 18.0,     // additional hill height
      maxSlopePerMeter: 1.2,    // limit height delta per 1m to avoid near-vertical faces
      walkMaxSlope: 0.9,        // maximum climb/descend slope per meter for movement
      treeDensity: 0.02,        // per m^2 probability
      rockDensity: 0.01,        // per m^2 probability
      birdCount: 8,             // total birds in the sky
      birdSpawnRadius: 150,     // radius around player to spawn birds
      birdHeight: [20, 50],     // min/max bird altitude
      birdSpeed: [3, 6],        // min/max bird speed (m/s)
      rabbitCount: 5,           // total rabbits on terrain
      rabbitSpawnRadius: 60,    // radius around player to spawn rabbits
      rabbitHopSpeed: 2.5,      // rabbit hop speed (m/s)
      rabbitPauseDuration: [2, 5], // pause time range (seconds)
      rabbitMoveDuration: [1, 3],  // hop time range (seconds)
      eyeLevel: 1.6,            // meters above ground for camera
      smoothingFactor: 0.2,     // camera vertical smoothing
      groundClearance: 0.15,    // extra clearance to avoid visual clipping into steep faces
      cameraMinHeight: 0.5,     // minimum camera height above terrain to prevent clipping
      // Valley flattening
      valleyScale: 0.02,        // frequency driving where valleys appear
      valleyDepthBias: 4.0,     // base depth threshold for flattening (lower = more flats)
      valleyJitter: 2.0,        // noise-driven variation of threshold
      valleyFlatness: 0.15,     // 0..1, closer to 0 = flatter bottoms
      seedOffset: 1000.0,       // offset to vary trees/rocks sampling
      bgRadius: 800,            // background sphere radius
      bgFrequency: 0.008,       // lower frequency for distant mountains
      bgAmplitude: 60,          // height variation for mountains
    };

    // Noise instances
    const noise2D = createNoise2D();
    const assetNoise2D = createNoise2D();

    // Height function using fractal simplex noise + macro hills
    function groundHeight(x, z) {
      // Fractal (FBM) noise for varied mid-scale features
      let amp = CONFIG.terrainAmplitude;
      let freq = CONFIG.terrainScale;
      let sum = 0;
      for (let o = 0; o < CONFIG.octaves; o++) {
        const n = noise2D(x * freq, z * freq);
        sum += n * amp;
        freq *= CONFIG.lacunarity;
        amp *= CONFIG.gain;
      }
      // Macro low-frequency hills for taller variations
      const macro = noise2D(x * CONFIG.macroScale, z * CONFIG.macroScale) * CONFIG.macroAmplitude;
      let h = sum + macro;
      // Valley flattening: compute a local threshold and compress heights below it
      const v = noise2D(x * CONFIG.valleyScale, z * CONFIG.valleyScale);
      const threshold = -CONFIG.valleyDepthBias + v * CONFIG.valleyJitter;
      if (h < threshold) {
        h = threshold + (h - threshold) * CONFIG.valleyFlatness;
      }
      return h;
    }

    // A-Frame system to track FPS and expose helpers
    AFRAME.registerSystem('world-system', {
      init() {
        this.last = performance.now();
        this.fps = 0;
        this.rig = document.getElementById('rig');
      },
      tick() {
        const now = performance.now();
        const dt = (now - this.last) / 1000;
        this.last = now;
        this.fps = clamp(1 / dt, 0, 120);
      }
    });

    // Camera grounding component: keeps rig at ground height + eyeLevel
    AFRAME.registerComponent('ground-follow', {
      schema: {},
      init() {
        this.system = this.el.sceneEl.systems['world-system'];
        this.y = this.el.object3D.position.y;
      },
      tick(time, dt) {
        const pos = this.el.object3D.position;
        const gy = groundHeight(pos.x, pos.z) + CONFIG.eyeLevel + CONFIG.groundClearance;
        // Enforce minimum height above terrain
        const minHeight = groundHeight(pos.x, pos.z) + CONFIG.cameraMinHeight;
        const targetY = Math.max(gy, minHeight);
        // Smooth vertical movement
        const a = clamp(CONFIG.smoothingFactor * (dt / 16), 0, 1);
        this.y = this.y + (targetY - this.y) * a;
        pos.y = this.y;
      }
    });

    // Apply camera grounding to rig
    document.getElementById('rig').setAttribute('ground-follow', '');

    // Auto-walk component: moves the rig forward along camera look direction
    AFRAME.registerComponent('auto-walk', {
      schema: {
        speed: { type: 'number', default: 2.5 }, // meters/sec
        enabled: { type: 'boolean', default: true }
      },
      init() {
        this.dir = new THREE.Vector3();
        this.tmp = new THREE.Vector3();
        this.camera = document.getElementById('camera');
        this.keys = { forward: true }; // start moving forward
        // Toggle walking with spacebar
        window.addEventListener('keydown', (e) => {
          if (e.code === 'Space') {
            this.data.enabled = !this.data.enabled;
          }
        });
      },
      tick(time, dt) {
        if (!this.data.enabled || !this.camera) return;
        const dts = dt / 1000;
        // Get camera forward vector and project to XZ plane
        this.camera.object3D.getWorldDirection(this.dir);
        this.dir.y = 0;
        if (this.dir.lengthSq() === 0) return;
        this.dir.normalize();
        // Three.js camera forward is -Z; invert to move toward gaze
        this.dir.multiplyScalar(-1);
        // Proposed next position
        const pos = this.el.object3D.position;
        const stepLen = this.data.speed * dts;
        const nextX = pos.x + this.dir.x * stepLen;
        const nextZ = pos.z + this.dir.z * stepLen;
        const curGY = groundHeight(pos.x, pos.z);
        const nextGY = groundHeight(nextX, nextZ);
        const slope = (nextGY - curGY) / Math.max(stepLen, 1e-4);
        // If slope exceeds walking threshold, reduce step to allowable slope
        if (Math.abs(slope) > CONFIG.walkMaxSlope) {
          const allowableStep = Math.max(Math.abs((CONFIG.walkMaxSlope * stepLen) / (Math.abs(slope) + 1e-6)), 0);
          pos.x += this.dir.x * allowableStep;
          pos.z += this.dir.z * allowableStep;
        } else {
          pos.x = nextX;
          pos.z = nextZ;
        }
      }
    });

    // Chunked terrain component
    AFRAME.registerComponent('chunked-terrain', {
      init() {
        this.chunks = new Map();
        this.worldRoot = this.el;
        this.system = this.el.sceneEl.systems['world-system'];
        this.system.terrainComp = this;
        this.toRemove = [];
        // Start after small delay to show loading screen
        setTimeout(() => {
          document.getElementById('loading').style.display = 'none';
        }, 600);
      },
      loadedChunkCount() { return this.chunks.size; },
      tick() {
        // Determine current chunk from rig position
        const rig = document.getElementById('rig').object3D.position;
        const cx = Math.floor(rig.x / CONFIG.chunkSize);
        const cz = Math.floor(rig.z / CONFIG.chunkSize);

        // Desired set of chunk keys within draw distance
        const need = new Set();
        for (let dz = -CONFIG.drawDistance; dz <= CONFIG.drawDistance; dz++) {
          for (let dx = -CONFIG.drawDistance; dx <= CONFIG.drawDistance; dx++) {
            const key = `${cx+dx},${cz+dz}`;
            need.add(key);
            if (!this.chunks.has(key)) {
              this.loadChunk(cx + dx, cz + dz);
            }
          }
        }
        // Unload far chunks
        this.chunks.forEach((chunk, key) => {
          if (!need.has(key)) {
            this.unloadChunk(key);
          }
        });
      },
      loadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (this.chunks.has(key)) return;

        const group = document.createElement('a-entity');
        group.setAttribute('position', `${cx*CONFIG.chunkSize} 0 ${cz*CONFIG.chunkSize}`);
        this.worldRoot.appendChild(group);

        // Generate terrain mesh for this chunk
        const terrain = this.makeTerrainMesh(cx, cz);
        group.object3D.add(terrain);

        // Procedural assets (trees, rocks)
        const assets = this.makeAssetsForChunk(cx, cz);
        assets.forEach(m => group.object3D.add(m));

        this.chunks.set(key, group);
      },
      unloadChunk(key) {
        const ent = this.chunks.get(key);
        if (!ent) return;
        if (ent.parentElement) ent.parentElement.removeChild(ent);
        this.chunks.delete(key);
      },
      makeTerrainMesh(cx, cz) {
        const size = CONFIG.chunkSize;
        const n = CONFIG.vertsPerSide;
        const geom = new THREE.BufferGeometry();
        const positions = new Float32Array(n * n * 3);
        const normals = new Float32Array(n * n * 3);
        const uvs = new Float32Array(n * n * 2);
        const indices = [];

        for (let j = 0; j < n; j++) {
          for (let i = 0; i < n; i++) {
            const idx = j * n + i;
            const x = cx * size + (i / (n - 1)) * size;
            const z = cz * size + (j / (n - 1)) * size;
            const y = groundHeight(x, z);
            positions[idx*3 + 0] = x - cx * size;
            positions[idx*3 + 1] = y;
            positions[idx*3 + 2] = z - cz * size;
            uvs[idx*2 + 0] = i / (n - 1);
            uvs[idx*2 + 1] = j / (n - 1);
          }
        }
        // Limit slope between adjacent vertices to avoid near-vertical facets
        const step = size / (n - 1);
        const maxDelta = CONFIG.maxSlopePerMeter * step;
        // Perform a couple of smoothing passes
        for (let pass = 0; pass < 2; pass++) {
          for (let j = 0; j < n; j++) {
            for (let i = 0; i < n; i++) {
              const idx = j * n + i;
              const y = positions[idx*3 + 1];
              // Compare with left and up neighbors
              // IMPORTANT: skip outer border so shared edges between chunks remain identical
              if (i === 0 || i === n-1 || j === 0 || j === n-1) continue;
              if (i > 0) {
                const lidx = j * n + (i - 1);
                const ly = positions[lidx*3 + 1];
                const d = y - ly;
                if (Math.abs(d) > maxDelta) {
                  const target = ly + Math.sign(d) * maxDelta;
                  positions[idx*3 + 1] = (y + target) * 0.5;
                }
              }
              if (j > 0) {
                const uidx = (j - 1) * n + i;
                const uy = positions[uidx*3 + 1];
                const d = y - uy;
                if (Math.abs(d) > maxDelta) {
                  const target = uy + Math.sign(d) * maxDelta;
                  positions[idx*3 + 1] = (positions[idx*3 + 1] + target) * 0.5;
                }
              }
            }
          }
        }
        // Indices for grid
        for (let j = 0; j < n - 1; j++) {
          for (let i = 0; i < n - 1; i++) {
            const a = j * n + i;
            const b = a + 1;
            const c = a + n;
            const d = c + 1;
            indices.push(a, c, b, b, c, d);
          }
        }
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
        geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        geom.computeVertexNormals();

        const material = new THREE.MeshLambertMaterial({
          color: 0x6b9c4a,
          flatShading: true,
        });
        const mesh = new THREE.Mesh(geom, material);
        mesh.receiveShadow = true;
        return mesh;
      },
      makeAssetsForChunk(cx, cz) {
        const size = CONFIG.chunkSize;
        const meshes = [];
        const area = size * size;
        const treeCount = Math.floor(area * CONFIG.treeDensity);
        const rockCount = Math.floor(area * CONFIG.rockDensity);

        // Helper to make a low-poly tree
        function makeTree(x, z, y) {
          const group = new THREE.Group();
          // Trunk
          const trunkGeom = new THREE.CylinderGeometry(0.2, 0.3, 2, 6);
          const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8b5a2b, flatShading: true });
          const trunk = new THREE.Mesh(trunkGeom, trunkMat);
          // Slight sinking to avoid floating on steep transitions
          trunk.position.set(x, y + 0.9, z);
          group.add(trunk);
          // Foliage
          const crownGeom = new THREE.ConeGeometry(1.2, 2.2, 6);
          const crownMat = new THREE.MeshLambertMaterial({ color: 0x2e8b57, flatShading: true });
          const crown = new THREE.Mesh(crownGeom, crownMat);
          crown.position.set(x, y + 2.1, z);
          group.add(crown);
          return group;
        }
        // Helper to make a low-poly rock
        function makeRock(x, z, y) {
          const geom = new THREE.DodecahedronGeometry(0.7, 0);
          const mat = new THREE.MeshLambertMaterial({ color: 0x808080, flatShading: true });
          const rock = new THREE.Mesh(geom, mat);
          // Slight sinking to avoid floating on steep transitions
          rock.position.set(x, y + 0.25, z);
          return rock;
        }

        // Random placements within chunk
        for (let k = 0; k < treeCount; k++) {
          const rx = Math.random() * size;
          const rz = Math.random() * size;
          const x = cx * size + rx;
          const z = cz * size + rz;
          // Ground precisely to terrain height at world coords
          const y = groundHeight(x, z);
          // Skip planting on steep slopes to avoid floating appearance
          const step = 0.5;
          const hdx = groundHeight(x + step, z) - groundHeight(x - step, z);
          const hdz = groundHeight(x, z + step) - groundHeight(x, z - step);
          const slopeMag = Math.sqrt(hdx*hdx + hdz*hdz) / (2*step);
          if (slopeMag < 0.5) {
            meshes.push(makeTree(x - cx * size, z - cz * size, y));
          }
        }
        for (let k = 0; k < rockCount; k++) {
          const rx = Math.random() * size;
          const rz = Math.random() * size;
          const x = cx * size + rx;
          const z = cz * size + rz;
          const y = groundHeight(x, z);
          // Skip rocks on steep slopes to avoid floating appearance
          const step = 0.5;
          const hdx = groundHeight(x + step, z) - groundHeight(x - step, z);
          const hdz = groundHeight(x, z + step) - groundHeight(x, z - step);
          const slopeMag = Math.sqrt(hdx*hdx + hdz*hdz) / (2*step);
          if (slopeMag < 0.5) {
            meshes.push(makeRock(x - cx * size, z - cz * size, y));
          }
        }
        return meshes;
      }
    });

    // Simple sky via <a-sky>; no distant background component

    // Bird flock component: spawns low-poly animated birds flying around the player
    AFRAME.registerComponent('bird-flock', {
      init() {
        this.birds = [];
        this.rig = document.getElementById('rig');
        
        // Create birds
        for (let i = 0; i < CONFIG.birdCount; i++) {
          const bird = this.createBird();
          this.birds.push(bird);
          this.el.object3D.add(bird.group);
        }
      },
      createBird() {
        const group = new THREE.Group();
        
        // Simple low-poly bird: body + two wings
        const bodyGeom = new THREE.ConeGeometry(0.15, 0.5, 4);
        bodyGeom.rotateX(Math.PI / 2);
        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x333333, flatShading: true });
        const body = new THREE.Mesh(bodyGeom, bodyMat);
        group.add(body);
        
        // Left wing
        const wingGeom = new THREE.BoxGeometry(0.8, 0.05, 0.3);
        const wingMat = new THREE.MeshLambertMaterial({ color: 0x444444, flatShading: true });
        const leftWing = new THREE.Mesh(wingGeom, wingMat);
        leftWing.position.set(-0.4, 0, 0);
        group.add(leftWing);
        
        // Right wing
        const rightWing = new THREE.Mesh(wingGeom, wingMat);
        rightWing.position.set(0.4, 0, 0);
        group.add(rightWing);
        
        // Random spawn position around player
        const angle = Math.random() * Math.PI * 2;
        const dist = CONFIG.birdSpawnRadius * (0.5 + Math.random() * 0.5);
        const rigPos = this.rig.object3D.position;
        group.position.set(
          rigPos.x + Math.cos(angle) * dist,
          CONFIG.birdHeight[0] + Math.random() * (CONFIG.birdHeight[1] - CONFIG.birdHeight[0]),
          rigPos.z + Math.sin(angle) * dist
        );
        
        // Random velocity
        const speed = CONFIG.birdSpeed[0] + Math.random() * (CONFIG.birdSpeed[1] - CONFIG.birdSpeed[0]);
        const dir = Math.random() * Math.PI * 2;
        
        return {
          group,
          leftWing,
          rightWing,
          velocity: new THREE.Vector3(Math.cos(dir) * speed, 0, Math.sin(dir) * speed),
          flapTime: Math.random() * Math.PI * 2,
          flapSpeed: 8 + Math.random() * 4,
          turnTimer: Math.random() * 5
        };
      },
      tick(time, dt) {
        const dts = dt / 1000;
        const rigPos = this.rig.object3D.position;
        
        this.birds.forEach(bird => {
          // Flap animation
          bird.flapTime += bird.flapSpeed * dts;
          const flap = Math.sin(bird.flapTime) * 0.4;
          bird.leftWing.rotation.z = flap;
          bird.rightWing.rotation.z = -flap;
          
          // Move bird
          bird.group.position.add(bird.velocity.clone().multiplyScalar(dts));
          
          // Point bird in direction of travel
          bird.group.lookAt(
            bird.group.position.x + bird.velocity.x,
            bird.group.position.y,
            bird.group.position.z + bird.velocity.z
          );
          
          // Occasional gentle turns
          bird.turnTimer -= dts;
          if (bird.turnTimer <= 0) {
            const turnAngle = (Math.random() - 0.5) * 0.8;
            bird.velocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), turnAngle);
            bird.turnTimer = 3 + Math.random() * 4;
          }
          
          // Keep birds near player (respawn if too far)
          const dx = bird.group.position.x - rigPos.x;
          const dz = bird.group.position.z - rigPos.z;
          const distSq = dx*dx + dz*dz;
          if (distSq > CONFIG.birdSpawnRadius * CONFIG.birdSpawnRadius * 2) {
            // Respawn on opposite side
            const angle = Math.atan2(-dz, -dx);
            const dist = CONFIG.birdSpawnRadius * 0.8;
            bird.group.position.set(
              rigPos.x + Math.cos(angle) * dist,
              CONFIG.birdHeight[0] + Math.random() * (CONFIG.birdHeight[1] - CONFIG.birdHeight[0]),
              rigPos.z + Math.sin(angle) * dist
            );
          }
        });
      }
    });

    // Rabbit pack component: spawns low-poly animated rabbits that hop and pause
    AFRAME.registerComponent('rabbit-pack', {
      init() {
        this.rabbits = [];
        this.rig = document.getElementById('rig');
        
        // Create rabbits
        for (let i = 0; i < CONFIG.rabbitCount; i++) {
          const rabbit = this.createRabbit();
          this.rabbits.push(rabbit);
          this.el.object3D.add(rabbit.group);
        }
      },
      createRabbit() {
        const group = new THREE.Group();
        
        // Simple low-poly rabbit: body, head, ears, legs
        const bodyGeom = new THREE.BoxGeometry(0.4, 0.3, 0.6);
        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8b7355, flatShading: true });
        const body = new THREE.Mesh(bodyGeom, bodyMat);
        body.position.set(0, 0.15, 0);
        group.add(body);
        
        // Head
        const headGeom = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        const head = new THREE.Mesh(headGeom, bodyMat);
        head.position.set(0, 0.25, 0.35);
        group.add(head);
        
        // Ears
        const earGeom = new THREE.BoxGeometry(0.08, 0.3, 0.08);
        const leftEar = new THREE.Mesh(earGeom, bodyMat);
        leftEar.position.set(-0.1, 0.5, 0.35);
        group.add(leftEar);
        const rightEar = new THREE.Mesh(earGeom, bodyMat);
        rightEar.position.set(0.1, 0.5, 0.35);
        group.add(rightEar);
        
        // Legs (for animation reference)
        const legGeom = new THREE.BoxGeometry(0.1, 0.2, 0.1);
        const legMat = new THREE.MeshLambertMaterial({ color: 0x7a5f4a, flatShading: true });
        const frontLeft = new THREE.Mesh(legGeom, legMat);
        frontLeft.position.set(-0.12, 0, 0.2);
        group.add(frontLeft);
        const frontRight = new THREE.Mesh(legGeom, legMat);
        frontRight.position.set(0.12, 0, 0.2);
        group.add(frontRight);
        
        // Random spawn position around player
        const angle = Math.random() * Math.PI * 2;
        const dist = CONFIG.rabbitSpawnRadius * (0.3 + Math.random() * 0.7);
        const rigPos = this.rig.object3D.position;
        const x = rigPos.x + Math.cos(angle) * dist;
        const z = rigPos.z + Math.sin(angle) * dist;
        const y = groundHeight(x, z);
        group.position.set(x, y, z);
        
        // Random initial state
        const isPaused = Math.random() > 0.5;
        const stateDuration = isPaused 
          ? CONFIG.rabbitPauseDuration[0] + Math.random() * (CONFIG.rabbitPauseDuration[1] - CONFIG.rabbitPauseDuration[0])
          : CONFIG.rabbitMoveDuration[0] + Math.random() * (CONFIG.rabbitMoveDuration[1] - CONFIG.rabbitMoveDuration[0]);
        
        const dir = Math.random() * Math.PI * 2;
        
        return {
          group,
          body,
          direction: dir,
          isPaused,
          stateTimer: stateDuration,
          hopTime: 0,
          hopCycle: 0.4 // hop animation cycle duration
        };
      },
      tick(time, dt) {
        const dts = dt / 1000;
        const rigPos = this.rig.object3D.position;
        
        this.rabbits.forEach(rabbit => {
          // State management
          rabbit.stateTimer -= dts;
          if (rabbit.stateTimer <= 0) {
            // Switch state
            rabbit.isPaused = !rabbit.isPaused;
            if (rabbit.isPaused) {
              rabbit.stateTimer = CONFIG.rabbitPauseDuration[0] + Math.random() * (CONFIG.rabbitPauseDuration[1] - CONFIG.rabbitPauseDuration[0]);
            } else {
              rabbit.stateTimer = CONFIG.rabbitMoveDuration[0] + Math.random() * (CONFIG.rabbitMoveDuration[1] - CONFIG.rabbitMoveDuration[0]);
              // New random direction
              rabbit.direction = Math.random() * Math.PI * 2;
            }
          }
          
          // Movement
          if (!rabbit.isPaused) {
            rabbit.hopTime += dts;
            const hopProgress = (rabbit.hopTime % rabbit.hopCycle) / rabbit.hopCycle;
            
            // Hop animation (vertical bounce)
            const bounce = Math.sin(hopProgress * Math.PI) * 0.15;
            
            // Move forward
            const speed = CONFIG.rabbitHopSpeed;
            const dx = Math.cos(rabbit.direction) * speed * dts;
            const dz = Math.sin(rabbit.direction) * speed * dts;
            const newX = rabbit.group.position.x + dx;
            const newZ = rabbit.group.position.z + dz;
            const newY = groundHeight(newX, newZ);
            
            rabbit.group.position.set(newX, newY + bounce, newZ);
            
            // Orient rabbit to direction
            rabbit.group.rotation.y = -rabbit.direction + Math.PI / 2;
            
            // Slight body tilt during hop
            rabbit.body.rotation.x = Math.sin(hopProgress * Math.PI) * 0.2;
          } else {
            // When paused, ensure grounded
            const groundY = groundHeight(rabbit.group.position.x, rabbit.group.position.z);
            rabbit.group.position.y = groundY;
            rabbit.body.rotation.x = 0;
          }
          
          // Keep rabbits near player (respawn if too far)
          const dx = rabbit.group.position.x - rigPos.x;
          const dz = rabbit.group.position.z - rigPos.z;
          const distSq = dx*dx + dz*dz;
          if (distSq > CONFIG.rabbitSpawnRadius * CONFIG.rabbitSpawnRadius * 2) {
            // Respawn closer to player
            const angle = Math.random() * Math.PI * 2;
            const dist = CONFIG.rabbitSpawnRadius * 0.5;
            const x = rigPos.x + Math.cos(angle) * dist;
            const z = rigPos.z + Math.sin(angle) * dist;
            const y = groundHeight(x, z);
            rabbit.group.position.set(x, y, z);
            rabbit.isPaused = true;
            rabbit.stateTimer = CONFIG.rabbitPauseDuration[0];
          }
        });
      }
    });

    // HUD removed
  </script>
</body>
</html>
