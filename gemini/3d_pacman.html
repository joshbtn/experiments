<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Pac-Man VR - Fixed Movement</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: #00ffff; font-family: 'Courier New', monospace;
            font-size: 28px; text-shadow: 0 0 10px #00ffff; z-index: 10;
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #111 0%, #000 100%); 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white;
            z-index: 100; font-family: sans-serif; text-align: center;
        }
        button {
            padding: 15px 40px; font-size: 24px; background: #00ffff;
            border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 20px #00ffff; color: #000;
        }
    </style>
</head>
<body>
    <div id="ui">SCORE: <span id="score">0</span></div>
    
    <div id="overlay">
        <h1 style="color: #00ffff; letter-spacing: 8px; font-size: 48px;">NEON PAC-MAN</h1>
        <p style="margin-bottom: 30px; opacity: 0.8;">Look down an open path to move.<br>If you hit a wall, look in a new direction to restart.</p>
        <button id="start-btn">ENTER THE GRID</button>
    </div>

    <script>
        const GRID_SIZE = 4;
        const MAZE = [
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1]
        ];

        let score = 0;
        let gameActive = false;

        AFRAME.registerComponent('pacman-logic', {
            schema: { speed: {default: 0.2} },
            init: function() {
                this.rig = this.el;
                this.camera = document.querySelector('#cam');
                this.currentDir = new THREE.Vector3(0, 0, 0);
                this.isMoving = false;
            },
            tick: function(t, dt) {
                if (!gameActive || !dt) return;

                // 1. Convert Camera Yaw to Grid Intent
                const camRot = this.camera.getAttribute('rotation');
                // Normalize rotation to 0-360
                let yaw = camRot.y % 360;
                if (yaw < 0) yaw += 360;

                let intent = {x: 0, z: 0};
                if (yaw >= 315 || yaw < 45) intent = {x: 0, z: -1};      // North (Forward)
                else if (yaw >= 45 && yaw < 135) intent = {x: -1, z: 0}; // West (Left)
                else if (yaw >= 135 && yaw < 225) intent = {x: 0, z: 1}; // South (Back)
                else if (yaw >= 225 && yaw < 315) intent = {x: 1, z: 0}; // East (Right)

                // 2. Continuous Direction Switching
                // If we aren't moving, OR if we want to change direction while moving
                const canMoveIntent = !this.checkWallAt(
                    this.rig.object3D.position.x + intent.x * (GRID_SIZE * 0.6), 
                    this.rig.object3D.position.z + intent.z * (GRID_SIZE * 0.6)
                );

                if (canMoveIntent) {
                    // Check if we are roughly centered in a tile before allowing a turn
                    const distToCenterX = Math.abs(this.rig.object3D.position.x % GRID_SIZE);
                    const distToCenterZ = Math.abs(this.rig.object3D.position.z % GRID_SIZE);
                    
                    // If stopped, or at an intersection, accept the new intent
                    if (!this.isMoving || (distToCenterX < 0.5 && distToCenterZ < 0.5)) {
                        if (intent.x !== this.currentDir.x || intent.z !== this.currentDir.z) {
                            this.currentDir.set(intent.x, 0, intent.z);
                            this.isMoving = true;
                        }
                    }
                }

                // 3. Movement Execution
                if (this.isMoving) {
                    const nextPos = this.rig.object3D.position.clone().addScaledVector(this.currentDir, this.data.speed);
                    
                    // Collision check with a small buffer
                    const collisionBuffer = 1.2;
                    const checkX = nextPos.x + this.currentDir.x * collisionBuffer;
                    const checkZ = nextPos.z + this.currentDir.z * collisionBuffer;

                    if (this.checkWallAt(checkX, checkZ)) {
                        // HIT WALL
                        this.isMoving = false;
                        this.currentDir.set(0, 0, 0);
                        // Snap to grid strictly on stop
                        this.rig.object3D.position.x = Math.round(this.rig.object3D.position.x / GRID_SIZE) * GRID_SIZE;
                        this.rig.object3D.position.z = Math.round(this.rig.object3D.position.z / GRID_SIZE) * GRID_SIZE;
                    } else {
                        this.rig.object3D.position.copy(nextPos);
                    }
                }
            },
            checkWallAt: function(x, z) {
                const gx = Math.round(x / GRID_SIZE);
                const gz = Math.round(z / GRID_SIZE);
                if (gz < 0 || gz >= MAZE.length || gx < 0 || gx >= MAZE[0].length) return true;
                return MAZE[gz][gx] === 1;
            }
        });

        AFRAME.registerComponent('ghost-ai', {
            init: function() {
                this.target = document.querySelector('#player-rig');
                this.dir = new THREE.Vector3(0, 0, 1);
                this.lastG = {x: -1, z: -1};
            },
            tick: function(t, dt) {
                if (!gameActive || !dt) return;
                const pos = this.el.object3D.position;
                pos.addScaledVector(this.dir, 0.07);

                const gx = Math.round(pos.x / GRID_SIZE);
                const gz = Math.round(pos.z / GRID_SIZE);

                if (gx !== this.lastG.x || gz !== this.lastG.z) {
                    const distToCenter = Math.sqrt(Math.pow(pos.x - gx*GRID_SIZE, 2) + Math.pow(pos.z - gz*GRID_SIZE, 2));
                    if (distToCenter < 0.3) {
                        this.chooseDir(gx, gz);
                        this.lastG = {x: gx, z: gz};
                    }
                }
                if (pos.distanceTo(this.target.object3D.position) < 1.5) {
                    location.reload();
                }
            },
            chooseDir: function(gx, gz) {
                const dirs = [{x:1, z:0}, {x:-1, z:0}, {x:0, z:1}, {x:0, z:-1}];
                const valid = dirs.filter(d => {
                    const nx = gx + d.x, nz = gz + d.z;
                    return MAZE[nz] && MAZE[nz][nx] === 0 && (d.x !== -this.dir.x || d.z !== -this.dir.z);
                });
                if (valid.length > 0) {
                    const pPos = this.target.object3D.position;
                    valid.sort((a,b) => {
                        const dA = Math.pow((gx+a.x)*GRID_SIZE - pPos.x, 2) + Math.pow((gz+a.z)*GRID_SIZE - pPos.z, 2);
                        const dB = Math.pow((gx+b.x)*GRID_SIZE - pPos.x, 2) + Math.pow((gz+b.z)*GRID_SIZE - pPos.z, 2);
                        return dA - dB;
                    });
                    this.dir.set(valid[0].x, 0, valid[0].z);
                } else { this.dir.multiplyScalar(-1); }
            }
        });

        AFRAME.registerComponent('pellet', {
            tick: function() {
                const p = document.querySelector('#player-rig').object3D.position;
                if (this.el.object3D.position.distanceTo(p) < 1.5) {
                    score += 10;
                    document.querySelector('#score').innerText = score;
                    this.el.parentNode.removeChild(this.el);
                }
            }
        });

        window.onload = () => {
            document.querySelector('#start-btn').onclick = () => {
                gameActive = true;
                document.querySelector('#overlay').style.display = 'none';
            };

            const mazeContainer = document.querySelector('#maze-container');
            const scene = document.querySelector('a-scene');

            const initMaze = () => {
                for (let z = 0; z < MAZE.length; z++) {
                    for (let x = 0; x < MAZE[z].length; x++) {
                        const px = x * GRID_SIZE, pz = z * GRID_SIZE;
                        if (MAZE[z][x] === 1) {
                            const wall = document.createElement('a-box');
                            wall.setAttribute('position', `${px} 2 ${pz}`);
                            wall.setAttribute('width', GRID_SIZE * 0.95);
                            wall.setAttribute('height', 4);
                            wall.setAttribute('depth', GRID_SIZE * 0.95);
                            wall.setAttribute('material', 'color: #000033; opacity: 0.3; transparent: true; side: double; metalness: 0.9; roughness: 0.1; emissive: #000066; emissiveIntensity: 0.5');
                            mazeContainer.appendChild(wall);

                            const wire = document.createElement('a-box');
                            wire.setAttribute('position', `${px} 2 ${pz}`);
                            wire.setAttribute('width', GRID_SIZE);
                            wire.setAttribute('height', 4.01);
                            wire.setAttribute('depth', GRID_SIZE);
                            wire.setAttribute('material', 'wireframe: true; color: #00ffff; opacity: 0.4; transparent: true');
                            mazeContainer.appendChild(wire);
                        } else {
                            const p = document.createElement('a-sphere');
                            p.setAttribute('position', `${px} 0.5 ${pz}`);
                            p.setAttribute('radius', 0.2);
                            p.setAttribute('color', '#00ffff');
                            p.setAttribute('material', 'emissive: #00ffff; emissiveIntensity: 2');
                            p.setAttribute('pellet', '');
                            mazeContainer.appendChild(p);
                        }
                    }
                }
            };
            if (scene.hasLoaded) initMaze(); else scene.addEventListener('loaded', initMaze);
        };
    </script>

    <a-scene background="color: #000" fog="type: exponential; color: #000; density: 0.04">
        <a-entity light="type: ambient; color: #444; intensity: 0.8"></a-entity>
        
        <a-entity id="player-rig" position="4 0 4" pacman-logic>
            <a-camera id="cam" look-controls="pointerLockEnabled: true">
                <a-cursor color="#00ffff" fuse="false"></a-cursor>
                <!-- Flashlight -->
                <a-light type="spot" intensity="2" distance="20" angle="45" color="#00ffff"></a-light>
                <a-light type="point" intensity="1" distance="5" color="#ffff00"></a-light>
            </a-camera>
        </a-entity>

        <a-entity id="maze-container"></a-entity>

        <!-- Blinky -->
        <a-entity ghost-ai position="36 1.5 28">
            <a-cone color="red" radius-bottom="0.8" height="2" material="emissive: #ff0000; emissiveIntensity: 1"></a-cone>
            <a-light type="point" color="red" intensity="3" distance="12"></a-light>
        </a-entity>

        <!-- Pinky -->
        <a-entity ghost-ai position="4 1.5 28">
            <a-cone color="pink" radius-bottom="0.8" height="2" material="emissive: #ff69b4; emissiveIntensity: 1"></a-cone>
            <a-light type="point" color="pink" intensity="3" distance="12"></a-light>
        </a-entity>

        <a-plane rotation="-90 0 0" width="200" height="200" material="color: #050505; roughness: 1"></a-plane>
        <a-grid-helper size="200" divisions="50" color-grid="#003333" color-center="#00ffff" position="0 0.01 0"></a-grid-helper>
    </a-scene>
</body>
</html>

